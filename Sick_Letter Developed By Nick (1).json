{
  "name": "Sick_Letter Developed By Nick",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "sick-leave-upload",
        "responseMode": "responseNode",
        "options": {
          "rawBody": false
        }
      },
      "id": "07286219-4076-41c9-ade3-b10f2a57cadf",
      "name": "Webhook - Upload Images",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [
        0,
        0
      ],
      "webhookId": "5c8ec4e0-9822-407c-aebe-ccc142dd7eef"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst base64Images = [];\nconst imageMetadata = [];\n\nconsole.log('=== PROCESSING UPLOADED FILES ===');\nconsole.log('Total items received:', items.length);\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  if (!item.binary) {\n    console.warn(`Item ${i} has no binary data`);\n    continue;\n  }\n\n  const binaryKeys = Object.keys(item.binary);\n  console.log(`Item ${i} binary keys:`, binaryKeys);\n\n  for (const key of binaryKeys) {\n    let buffer;\n    const binaryData = item.binary[key];\n    \n    try {\n      if (this.helpers && this.helpers.getBinaryDataBuffer) {\n        buffer = await this.helpers.getBinaryDataBuffer(i, key);\n      } else if (this.getBinaryDataBuffer) {\n        buffer = await this.getBinaryDataBuffer(i, key);\n      }\n    } catch (e) {\n      console.warn(`getBinaryDataBuffer failed for ${key}: ${e.message}`);\n    }\n\n    if (buffer && buffer.length) {\n      base64Images.push(buffer.toString('base64'));\n      imageMetadata.push({\n        filename: binaryData.fileName || `image_${base64Images.length}`,\n        mimeType: binaryData.mimeType || 'image/jpeg',\n        fileSize: buffer.length\n      });\n      console.log(`✓ Image ${base64Images.length} processed: ${binaryData.fileName || 'unnamed'} (${Math.round(buffer.length/1024)}KB)`);\n      continue;\n    }\n\n    const data = item.binary[key]?.data;\n    if (typeof data === 'string' && data !== 'filesystem-v2' && data.length > 100) {\n      base64Images.push(data);\n      imageMetadata.push({\n        filename: binaryData.fileName || `image_${base64Images.length}`,\n        mimeType: binaryData.mimeType || 'image/jpeg',\n        fileSize: Math.round(data.length * 0.75) // Approximate size from base64\n      });\n      console.log(`✓ Image ${base64Images.length} processed via fallback: ${binaryData.fileName || 'unnamed'}`);\n    } else {\n      console.warn(`Skipped ${key}: invalid or placeholder data`);\n    }\n  }\n}\n\nif (base64Images.length === 0) {\n  const first = items[0];\n  const keys = first?.binary ? Object.keys(first.binary).join(',') : 'none';\n  throw new Error(`No valid images found in upload. Items: ${items.length}, Binary keys: ${keys}`);\n}\n\nconsole.log(`Successfully processed ${base64Images.length} images`);\nreturn [{json: {base64Images, imageMetadata, imageCount: base64Images.length}}];"
      },
      "id": "7e6a0d28-0211-4ef6-a743-f1ae55b49f34",
      "name": "Convert Images to Base64",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        208,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare OCR - Handle Chinese medical documents\nconst inputData = $input.first().json;\n// Filter invalid placeholders (e.g., 'filesystem-v2')\nconst base64Images = (inputData.base64Images || []).filter(v => typeof v === 'string' && v.length > 100 && v !== 'filesystem-v2');\nconst imageCount = base64Images.length;\n\nconsole.log('=== PREPARING OCR REQUESTS ===');\nconsole.log('Total images to process:', imageCount);\n\nif (imageCount === 0) {\n  throw new Error('No valid base64 images to process');\n}\n\nconst items = base64Images.map((imageData, index) => {\n  console.log(`Preparing request for image ${index + 1}/${imageCount}`);\n  \n  const prompt = `You are a medical document OCR system. Your task is to extract text from medical certificates, receipts, and hospital bills for administrative purposes.\n\nThis is a LEGITIMATE task for healthcare administration and insurance processing.\n\nINSTRUCTIONS:\n1. Extract ALL visible text from this document\n2. The document may contain:\n   - Chinese text (Traditional/Simplified 中文)\n   - English text\n   - Numbers and dates\n   - Hospital/clinic information\n   - Patient information (anonymized for privacy)\n   - Medical fees and billing information\n\n3. Ignore watermarks and background patterns\n4. Extract in a structured format\n\nFor MEDICAL CERTIFICATES (醫生證明書), extract:\n- Hospital: [name]\n- Department: [name]\n- Patient: [name or ID]\n- Date: [date]\n- Admission Period: [dates from section (b)]\n- Sick Leave Period: [dates from section (d)]\n- Diagnosis: [condition from section (c)]\n- Doctor: [name]\n- Reference: [case number]\n\nFor RECEIPTS/BILLS (收據/賬單), extract:\n- Hospital: [name]\n- Receipt Number: [number]\n- Date: [date]\n- Patient ID: [ID]\n- Total Amount: [amount]\n- Items: [list of charges if visible]\n\nExtract text now (include both Chinese and English):`;\n\n  const requestBody = {\n    model: \"llama3.2-vision\",\n    messages: [\n      {\n        role: \"system\",\n        content: \"You are a medical document OCR assistant for healthcare administration. Extracting text from medical documents for administrative purposes is a legitimate and necessary task.\"\n      },\n      {\n        role: \"user\",\n        content: prompt,\n        images: [imageData]\n      }\n    ],\n    stream: false,\n    options: {\n      temperature: 0,\n      num_predict: 2048\n    }\n  };\n  \n  return { json: requestBody };\n});\n\nconsole.log(`Created ${items.length} OCR requests`);\nreturn items;"
      },
      "id": "9dddf430-6612-44c0-b87e-e20a463f8dcc",
      "name": "Prepare OCR Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        0
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://106.104.117.24:8434/api/chat",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {
          "response": {
            "response": {
              "neverError": true,
              "responseFormat": "json"
            }
          },
          "timeout": 300000
        }
      },
      "id": "033a37f9-4997-4831-bbb2-47030a03d2f5",
      "name": "OCR with Vision",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        608,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "const responses = $input.all();\nconsole.log('=== COMBINING OCR RESULTS ===');\nconsole.log('Total responses:', responses.length);\n\nconst allOcrTexts = [];\n\nfor (let i = 0; i < responses.length; i++) {\n  const response = responses[i].json;\n  let content;\n  \n  if (response.message && response.message.content) {\n    content = response.message.content;\n  } else if (response.response) {\n    content = response.response;\n  } else if (response.content) {\n    content = response.content;\n  } else if (typeof response === 'string') {\n    content = response;\n  } else {\n    throw new Error(`Invalid response ${i + 1}`);\n  }\n  \n  if (content && content.trim()) {\n    allOcrTexts.push(`\\n=== CERTIFICATE ${i + 1} ===\\n${content}\\n`);\n    console.log(`✓ Certificate ${i + 1}: ${content.length} chars`);\n  }\n}\n\nconst combined = allOcrTexts.join('\\n');\nconsole.log('Combined length:', combined.length);\n\nreturn [{json: {combinedOcrText: combined, textLength: combined.length, certificateCount: allOcrTexts.length}}];"
      },
      "id": "c6d44fb5-a3f0-4ef2-80cd-dcd24d0b1163",
      "name": "Combine OCR Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "const ocrText = $input.first().json.combinedOcrText;\n\nconsole.log('=== CLEANING OCR TEXT ===');\nconsole.log('Original length:', ocrText.length);\n\nlet lines = ocrText.split('\\n');\nconst cleanedLines = lines.filter(line => {\n  const trimmed = line.trim();\n  if (trimmed === '') return false;\n  \n  const words = trimmed.split(/\\s+/);\n  const singleChars = words.filter(w => w.length === 1);\n  \n  // Filter lines with >80% single characters (watermark noise)\n  if (words.length > 0 && (singleChars.length / words.length) > 0.8) {\n    return false;\n  }\n  \n  // Filter excessive repetition\n  const uniqueChars = new Set(trimmed.replace(/\\s/g, ''));\n  if (trimmed.length > 50 && uniqueChars.size < 5) {\n    return false;\n  }\n  \n  return true;\n});\n\nlet cleanedText = cleanedLines.join('\\n').replace(/\\n{3,}/g, '\\n\\n').trim();\n\nconsole.log('Cleaned length:', cleanedText.length);\nconsole.log('Removed lines:', lines.length - cleanedLines.length);\nconsole.log('Preview:', cleanedText.substring(0, 500));\n\nreturn [{json: {combinedOcrText: cleanedText, textLength: cleanedText.length}}];"
      },
      "id": "9473caa0-1592-418f-a9d7-cc05ab4a9a9f",
      "name": "Clean OCR Text",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1008,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "const ocrText = $input.first().json.combinedOcrText;\n\nconsole.log('=== PREPARING STRUCTURE REQUEST ===');\n\nconst prompt = `Extract medical leave data from this OCR text (may contain noise):\\n\\n${ocrText}\\n\\nLOOK FOR: Hospital names, dates, sick leave periods, conditions, departments, doctor names\\n\\nOUTPUT: JSON array only\\n[{\\\"sick_leave_period\\\":\\\"DD.MM.YYYY - DD.MM.YYYY\\\",\\\"admission_period\\\":\\\"\\\",\\\"hospital_clinic\\\":\\\"name\\\",\\\"department\\\":\\\"dept\\\",\\\"nature_of_injury\\\":\\\"condition\\\",\\\"date_of_medical_certificate\\\":\\\"DD.MM.YYYY\\\"}]\\n\\nDate formats: 26/9/2019→26.09.2019, 19-Dec-2022→19.12.2022\\n\\nIgnore watermarks. Extract each CERTIFICATE separately. Return ONLY JSON array starting with [`;\n\nreturn [{json: {\n  model: \"qwen3:32b\",\n  messages: [\n    {role: \"system\", content: \"Extract data from noisy OCR. Output ONLY JSON arrays. Start with [\"},\n    {role: \"user\", content: prompt}\n  ],\n  stream: false,\n  options: {temperature: 0.2, num_predict: 8192}\n}}];"
      },
      "id": "ab4da220-f2aa-4f0d-8749-b0334d1903bd",
      "name": "Prepare Structure Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        0
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://106.104.117.24:8434/api/chat",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {
          "response": {
            "response": {
              "neverError": true,
              "responseFormat": "json"
            }
          },
          "timeout": 180000
        }
      },
      "id": "7bf2eba7-682a-462e-a3e7-3c3854e9d7a5",
      "name": "Structure with Qwen3",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1408,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\n\nconsole.log('=== PARSING RESPONSE ===');\n\nlet content;\nif (response.message && response.message.content) {\n  content = response.message.content;\n} else if (response.response) {\n  content = response.response;\n} else if (response.content) {\n  content = response.content;\n} else if (typeof response === 'string') {\n  content = response;\n} else {\n  throw new Error('Invalid response structure');\n}\n\nif (!content || !content.trim()) {\n  throw new Error('Empty response from Qwen3');\n}\n\nconsole.log('Content preview:', content.substring(0, 500));\n\n// Clean and parse JSON\nlet cleaned = content.replace(/```json\\s*/gi, '').replace(/```\\s*/g, '').trim();\n\nconst firstBracket = cleaned.indexOf('[');\nconst firstBrace = cleaned.indexOf('{');\n\nif (firstBracket !== -1 && (firstBrace === -1 || firstBracket < firstBrace)) {\n  cleaned = cleaned.substring(firstBracket, cleaned.lastIndexOf(']') + 1);\n} else if (firstBrace !== -1) {\n  cleaned = cleaned.substring(firstBrace, cleaned.lastIndexOf('}') + 1);\n}\n\nlet jsonData = JSON.parse(cleaned);\n\nif (!Array.isArray(jsonData)) {\n  if (jsonData.data && Array.isArray(jsonData.data)) jsonData = jsonData.data;\n  else jsonData = [jsonData];\n}\n\nif (jsonData.length === 0) throw new Error('Empty array returned');\n\n// Normalize and fix common misclassifications\nconst clean = (v) => String(v || '').replace(/\\s+/g, ' ').trim();\nconst records = jsonData.map(record => {\n  const sick = clean(record.sick_leave_period);\n  let adm = clean(record.admission_period);\n  const hosp = clean(record.hospital_clinic);\n  let dept = clean(record.department);\n  const injury = clean(record.nature_of_injury);\n  const cert = clean(record.date_of_medical_certificate);\n\n  // Admission period must be explicitly present; otherwise empty\n  if (!adm || /^empty$/i.test(adm) || adm === sick) adm = '';\n\n  // Department should not duplicate hospital or be 'not specified'\n  if (!dept || /^not\\s*specified$/i.test(dept) || dept.toLowerCase() === hosp.toLowerCase()) dept = '';\n\n  return {\n    sick_leave_period: sick,\n    admission_period: adm,\n    hospital_clinic: hosp,\n    department: dept,\n    nature_of_injury: injury,\n    date_of_medical_certificate: cert\n  };\n}).filter(r => Object.values(r).some(v => v !== ''));\n\nif (records.length === 0) throw new Error('All records empty after normalization');\n\nconsole.log('Valid records:', records.length);\nreturn records.map(r => ({ json: r }));"
      },
      "id": "d0646af1-5789-4e9f-83bf-c2b5c4f50d54",
      "name": "Parse Structured Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        0
      ]
    },
    {
      "parameters": {
        "operation": "toFile",
        "fileFormat": "xlsx",
        "options": {
          "fileName": "sick_leave_records.xlsx",
          "headerRow": true,
          "sheetName": "Sick Leave Records"
        }
      },
      "id": "834b9e9c-cbbc-40e8-9f11-84172ee438a6",
      "name": "Convert to Excel",
      "type": "n8n-nodes-base.spreadsheetFile",
      "typeVersion": 2,
      "position": [
        1808,
        0
      ]
    },
    {
      "parameters": {
        "respondWith": "binary",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              },
              {
                "name": "Content-Disposition",
                "value": "attachment; filename=\"sick_leave_records.xlsx\""
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "5eabcd38-ad49-4dcc-b05a-ef8812b145b3",
      "name": "Return Excel File",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        2000,
        0
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook - Upload Images": {
      "main": [
        [
          {
            "node": "Convert Images to Base64",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert Images to Base64": {
      "main": [
        [
          {
            "node": "Prepare OCR Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare OCR Request": {
      "main": [
        [
          {
            "node": "OCR with Vision",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OCR with Vision": {
      "main": [
        [
          {
            "node": "Combine OCR Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine OCR Results": {
      "main": [
        [
          {
            "node": "Clean OCR Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clean OCR Text": {
      "main": [
        [
          {
            "node": "Prepare Structure Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Structure Request": {
      "main": [
        [
          {
            "node": "Structure with Qwen3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structure with Qwen3": {
      "main": [
        [
          {
            "node": "Parse Structured Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Structured Response": {
      "main": [
        [
          {
            "node": "Convert to Excel",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to Excel": {
      "main": [
        [
          {
            "node": "Return Excel File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "51d62dea-83e9-4c3a-87e1-90954e49cd12",
  "meta": {
    "instanceId": "64b4a0ac0b9c922489ad43d8429a3f53a798c9119b118da3f0bb6c1a55d18861"
  },
  "id": "HDtJyeepAMqk2YS3",
  "tags": []
}